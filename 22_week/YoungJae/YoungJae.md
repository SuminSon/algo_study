# BOJ_1234 크리스마스 트리

## 문제 주소
https://www.acmicpc.net/problem/1234

- 문제
오민식은 오늘이 크리스마스라고 생각해서, 크리스마스 트리를 만들려고 한다. 트리는 N개의 레벨로 이루어져 있다. 위에서부터 레벨1, ... 레벨 N이다. 또, 민식이는 빨강, 파랑, 초록색의 장난감을 가지고 있다. 그리고 민식이는 이 장난감을 일정한 규칙에 의해서 장식하려고 한다.

레벨 K에는 딱 K개의 장난감이 있어야 한다. 또, 각 레벨에 놓으려고 선택한 색이 있으면, 그 색의 장난감의 수는 서로 같아야 한다. 예를 들어, 레벨 3에 장난감을 놓으려고 할 때, 빨강 2, 파랑 1과 같이 놓으면, 빨강과 파랑의 수가 다르기 때문에 안 된다. 하지만, 레벨 4에 빨강 2, 파랑 2와 같이 놓으면, 가능하다.

N과, 장난감의 수가 주어질 때, 트리를 장식하는 경우의 수를 출력하는 프로그램을 작성하시오.

- 입력
첫째 줄에 트리의 크기 N, 빨강의 개수, 초록의 개수, 파랑의 개수가 주어진다. N은 10보다 작거나 같다. 빨강, 초록, 파랑의 개수는 0보다 크거나 같고, 100보다 작거나 같다.

- 출력
첫째 줄에 경우의 수를 출력한다. 만약 주어진 장난감으로 트리를 장식할 수 없으면 0을 출력한다. 문제의 정답은 263-1보다 작거나 같다.

## 문제 접근 방법
DP와 DFS를 이용한 문제였다.
작은 레벨부터 가능한 경우에 대한 다음레벨 값을 구해 더하는 top-down 방식으로 해결하였다.

### 코드
```python
from math import factorial as f

# DFS, 현재 레벨 m, 남은 장난감 개수 rr, gg, bb
def dfs(m, rr, gg, bb):
    # 레벨 끝이면 1 출력
    if m > n: return 1
    # DP: 이미 있으면 DFS 대신 불러오기
    if dp[m][rr][gg][bb] != -1: return dp[m][rr][gg][bb]
    c = 0
    # 0 ~ (m, rr 중 최솟값)까지 반복
    for i in range(min(m, rr)+1):
        # 0 ~ (m-i, gg 중 최솟값)까지 반복
        for j in range(min(m-i, gg)+1):
            # 나머지 채워야 할 장난감을 k로 채움
            k = m-i-j
            # k가 음수거나 가진 개수보다 많으면 패스
            if k > bb or k < 0: continue
            # 들어가는 장난감 색이 동일한지 확인
            # 0 아닌 것들만 tt에 넣은 뒤 최댓값 최솟값 같은지 확인
            tt = []
            for t in [i, j, k]:
                if t: tt.append(t)
            if max(tt) != min(tt): continue
            # 조건을 만족하면 다음 레벨 값 추가
            # 장난감 배치 경우의 수 (r+g+b)!/r!g!b! 곱해줘야 함
            c += dfs(m+1, rr-i, gg-j, bb-k) * f(i+j+k)//(f(i)*f(j)*f(k))
    # DP에 저장
    dp[m][rr][gg][bb] = c
    return c

n, r, g, b = map(int, input().split())
dp = [[[[-1]*56 for _ in range(56)] for _ in range(56)] for _ in range(n+1)]
print(dfs(1, r, g, b))
```

### 시간복잡도
O(M * M * N) = O(NM²)

### 공간복잡도
O(11 * 56 * 56  56) = O(2000000)

# 느낀 점
크리스마스 기념으로 골랐는데 풀이방법이 저번주와 같은 DFS-DP 문제여서 놀랐던 문제였다.