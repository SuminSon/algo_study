# BOJ_14552 Mahjong

## 문제 주소
https://www.acmicpc.net/problem/14552

- 문제
알렉스는 마작을 좋아한다. 그는 마작을 연습하기 위해서 프로그램을 만들려고 한다.

마작은 136개의 패를 가지고 하는 게임이다. 우리는 마작을 단순화 시켜서 삭수패 9종류(1삭, 2삭, 3삭, 4삭, 5삭, 6삭, 7삭, 8삭, 9삭)를 4개씩, 총 36개의 패만 가지고 프로그램을 만든다.

마작에는 머리와 몸통이라는 개념이 존재한다. 머리는 같은 패 2개의 조합을 말한다. 몸통은 연속된 패 3개 혹은 같은 패 3개의 조합을 말한다. 다음은 머리 혹은 몸통인 것과 그렇지 않은 것의 예를 나타낸다:

(2삭): 패가 하나이므로, 머리도 몸통도 될 수 없다.
(3삭, 3삭): 같은 패 2개가 있으므로, 이 두 패의 조합은 머리이다.
(7삭, 8삭, 9삭): 7, 8, 9는 연속된 수 이므로, 이 세 패의 조합은 몸통이다.
(1삭, 3삭, 5삭): 1, 3, 5는 연속된 수가 아니다. (서로 1씩 차이가 나야한다.) 그러므로, 이 세 패의 조합은 몸통이 아니다.
(8삭, 9삭, 1삭): 9삭과 1삭은 연속된 수가 아니다 (둥글게 이을 수 없다.)
(9삭, 9삭, 9삭): 같은 패 3개가 있으므로, 이 세 패의 조합은 몸통이다.
(4삭, 5삭, 4삭): 4, 4, 5는 연속된 세 수가 아니다. 그러므로, 이 세 패의 조합은 몸통이 아니다.
(8삭, 8삭, 8삭, 8삭): 패가 4개 이므로, 머리도 몸통도 될 수 없다. 

36개의 패 중 적당히 14개를 모아서, 머리 1개와 몸통 4개 혹은 머리 7개의 조합으로 만들려고 한다. 각 패는 반드시 하나의 머리나 하나의 몸통에 속해야 한다. 이를 패가 완성되었다고 한다. 단, 머리 7개를 모을 때, 같은 종류의 머리가 2개 있으면 안 된다. 패 13개가 있을 때, 적당한 한 개의 패를 더 가져와서, 패를 14개로 만들어 완성시키려고 한다. 자기가 13개의 패가 있고, 남은 23개 중 어떤 패를 한 개 가져 왔을 때, 그 패가 완성될 수 있다면, 그것을 대기패 라고 한다. 그는 13개의 패가 있을때, 대기패를 찾는 법을 연습하고 있다. 알렉스를 도와주자!

- 입력
첫째 줄에는, 지금 가지고 있는 13개의 패가 1부터 9까지의 숫자로 공백으로 구분되어 들어온다.

- 출력
대기패를 오름차순으로 공백으로 구분하여 하나씩 출력하여라. 단, 대기패가 없다면, -1을 출력하여라.

## 문제 접근 방법
백트래킹을 이용하여 문제를 풀었다.

Baby-gin을 풀었을 때처럼 같은 패 3장일 때, 머리일 때, 연속된 세 패가 있을 때를 확인하여 머리와 몸통을 모두 구성할 때까지 재귀를 사용하였다.
단, 반복에 쓰일 i를 함수로 보내주고, for문이 아닌 while문을 사용하여 조금이나마 불필요한 반복을 줄였다.
또한, 완성된 경우 최대한 빨리 return으로 끊어주고, 아닌 경우 원상복구를 시켜주는 백트래킹 기법을 활용하였다.
이러한 기법을 바탕으로 1~9의 경우를 확인해 리스트에 넣어주는 것으로 해결하였다.

### 코드
```python
# 패 체크 함수, h는 머리, b는 몸통, i는 체크한 위치
def chkpae(pp, h=0, b=0, i=1):
    # 머리 1개, 몸통 4개가 모두 만들어졌으면 True 반환
    if h == 1 and b == 4: return True
    # 패 복사해서 가져오기
    pae = pp[:]
    # 낮은 숫자부터 패 확인
    while i < 10:
        # 패를 가지고 있다면
        if pae[i] > 0:
            # 3장 이상이고 몸통이 4 미만이면 몸통으로 넣고 되는지 확인
            if pae[i] >= 3 and b < 4:
                pae[i] -= 3; rst = chkpae(pae, h, b+1, i)
                # 된다면 더 할 것 없이 바로 종료
                if rst: return True
                # 안되면 원상복구
                pae[i] += 3
            # 2장 이상이고 머리가 없으면 머리로 넣고 확인
            if pae[i] >= 2 and not h:
                pae[i] -= 2; rst = chkpae(pae, h+1, b, i)
                if rst: return True
                pae[i] += 2
            # 연속된 세 숫자가 있으면 몸통에 넣고 확인
            if i < 8 and pae[i+1] and pae[i+2]:
                pae[i] -= 1; pae[i+1] -= 1; pae[i+2] -= 1
                rst = chkpae(pae, h, b+1, i)
                if rst: return True
            # 모두 안되면 남는 패가 있으므로 불가능 선언
            return False
        else: i += 1


ls = list(map(int, input().split()))
# 패 세팅 (i번째 패가 몇 개 있는지로 변경)
pae = [0]*10
for i in ls: pae[i] += 1
rst = []
# 대기패 확인, 1부터 한 패씩 패에 넣어봄
for i in range(1, 10):
    # 패는 4장까지이므로 4장이면 넘어감
    if pae[i] == 4: continue
    pp = pae[:]
    # 패에 추가
    pp[i] += 1
    # 치또이(머리 7개) 확인
    p7 = 0
    for j in range(1, 10):
        if pp[j] == 2: p7 += 1
    if p7 == 7: rst.append(i)
    # 아니면 완성 되는지 확인
    elif chkpae(pp): rst.append(i)
if rst: print(*rst)
else: print(-1)
```

### 시간복잡도
O(4000)?

### 공간복잡도
O(100)?

# 느낀 점
우선순위 큐를 2번 쓰는 것이 조금 신박했던 문제였다.