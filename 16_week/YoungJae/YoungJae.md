# BOJ_2638 치즈

## 문제 주소
https://www.acmicpc.net/problem/2638

- 문제
N×M의 모눈종이 위에 아주 얇은 치즈가 <그림 1>과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다. 그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서 적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다. 따라서 아래 <그림 1> 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다.

<그림 1>

<그림 2>와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다. 그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다. 그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 <그림 3>에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다.

<그림 2>

<그림 3>

모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다. 입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.

- 입력
첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5 ≤ N, M ≤ 100)이 주어진다. 그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다. 또한, 각 0과 1은 하나의 공백으로 분리되어 있다.

- 출력
출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.

## 문제 접근 방법
큰 틀은 델타탐색을 통한 BFS였다.

매일 (0,0)부터 BFS탐색을 통해 맵 전체를 탐색한다.
만약 해당 지역에 치즈가 있으면 카운트를 늘린 후 2 이상이 되면 체크해둔 후 모든 탐색이 끝나면 녹이는 식으로 하루를 진행한다.
남아있는 치즈가 없으면 반복을 멈추고 반복한 일수를 출력해준다.

### 코드
```python
from collections import deque

# 델타 탐색
dy, dx = [-1, 1, 0, 0], [0, 0, -1, 1]
n, m = map(int, input().split())
mp = []
# 남아있는 치즈 개수, 최종 출력 일수 CheeZe, ReSulT
cz, rst = 0, 0

# 맵 정보 가져오면서 cz 개수 확인
for i in range(n):
    mp.append(list(map(int, input().split())))
    for j in range(m):
        if mp[i][j]: cz += 1

# 치즈가 사라질 때까지 반복
while cz:
    # 하루가 지났기 때문에 rst += 1
    rst += 1
    # 방문 여부 체크 vs
    vs = [[1]*m for _ in range(n)]
    # 0,0에서 시작할거기 때문에 0으로 vs 체크
    vs[0][0] = 0
    # 녹은 치즈 저장용 MelT
    mt = set()
    # queue에 0,0 좌표 입력
    q = deque([(0, 0)])
    # BFS
    while q:
        y, x = q.popleft()
        # 델타 탐색
        for d in range(4):
            ny, nx = y+dy[d], x+dx[d]
            # 맵 안이고 방문한 적 없으면
            if 0 <= ny < n and 0 <= nx < m and mp[ny][nx] >= 0 and vs[ny][nx]:
                # 치즈가 있으면 vs에 1 추가
                # 3 이상(=2 초과)이면 두 면 이상 닿은 것이기 때문에 mt에 추가
                # 치즈 내부 공기는 BFS로 인해 방문을 못하기 때문에 괜찮다
                if mp[ny][nx]:
                    vs[ny][nx] += 1
                    if vs[ny][nx] > 2: mt.add((ny, nx))
                # 치즈가 아니면 vs 체크 후 queue에 추가
                else:
                    vs[ny][nx] = 0
                    q.append((ny, nx))
    # 녹은 치즈들 지워주고 남은 치즈 개수 줄이기
    for y, x in mt: mp[y][x] = 0; cz -= 1
print(rst)
```
### 시간복잡도
O(NM) + O((rst)NM) = O((rst)NM) = O(NM)

### 공간복잡도
O(2NM + max(N, M)) = O(NM)

# 느낀 점
치즈 내부에 닿는 부분을 고려하지 않는 것이 가장 고민이 되는 부분이였지만, 외부에서 BFS를 하여 치즈부분을 BFS에서 제외하면 내부로 들어가는 일이 없어 이러한 걱정을 해결할 수 있었다.